////
Codificación, idioma, tabla de contenidos, tipo de documento
////
:encoding: utf-8
:lang: es
:toc: right
:toc-title: Tabla de contenidos
:keywords: CI/CD Jenkins Pipelines NodeJs Docker KeystoneJs
:doctype: book
:icons: font

////
/// activar btn:
////
:experimental:

:source-highlighter: rouge
:rouge-linenums-mode: inline

// :highlightjsdir: ./highlight

:figure-caption: Fig.
:imagesdir: images


////
Nombre y título del trabajo
////
= Despliegue continuo y entrega continua

Computación en la nube servicios y aplicaciones.
Version 1.2.
Joaquín Cañadas <jjcanada@ual.es>

// Entrar en modo no numerado de apartados
:numbered!: 

[abstract]
////
COLOCA A CONTINUACION EL RESUMEN
////
Tema 3. Despliegue Continuo

////
COLOCA A CONTINUACION LOS OBJETIVOS
////
.Objetivos
* Crear una infraestructura de CI/CD en GCP con Máquinas Virtuales gestionadas con Terraform
* Diseñar proyectos Jenkins para la construcción y despliegue automatizado de aplicaciones en Java y NodeJs

.Realización y entrega
****
La realización de estas actividades se realizará de forma **individual**. Serán la base para actividades posteriores que ser harán en equipo. 
La entrega será mediante el envío de un informe y el acceso al profesor a los servicios configurados por cada estudiante, para la revisión y evaluación de los mismos. 
****

// Entrar en modo numerado de apartados
:numbered:

== Prerrequisitos

Para comenzar a trabajar, será necesario tener instalados en la máquina local las siguientes herramientas: Terraform, Google Cloud CLI. Se presupone que ya se tiene instalado un entorno de desarrollo como Visual Studio Code, y una pareja de claves SSH personal en la carpeta `HOME` del usuario (`~`).

[source,subs="verbatim,quotes"]
----
~/.ssh/
├── id_rsa <1>
└── id_rsa.pub <2>
----
<1> clave privada
<2> clave pública

Además, se debe disponer de crédito en GCP, proporcionado por el profesor, y darse de alta en Github Student Education Pack. A continuación se describen en detalle estos requisitos previos.

=== Cupones educativos Google Cloud

Si ya dispones de crédito en GCP, podrás usarlo ahora. En cualquier caso, para esta asignatura disponemos de un nuevo cupón educativo de 50$ por estudiante, que no necesita tarjeta de crédito para su activación. Actívalo en la dirección que habrá recibido en tu email, usando tu email __@inlumine.ual.es__.

*Crea un nuevo proyecto* GCP con el nombre *cnsa2021-__abc123__* (sustituyendo __abc123__ por tu nombre de usuario), y dale permisos al profesor. Para ello, revisa las instrucciones que vimos en la asignatura del primer cuatrimestre. El crédito del cada cupón dura 12 meses, así que este nuevo proyecto asígnalo a la cuenta de facturación de la asignatura del primer cuatrimestre, ya que es mejor consumir ese crédito porque caduca antes. Si se consume el crédito del primer cupón, simplemente tendrás que cambiar tu proyecto *cnsa2021-__abc123__* a la nueva cuenta de facturación del nuevo cupón.

=== Terraform

Terraform es una aplicación que se distribuye en un único archivo ejecutable. Las instrucciones de instalación de Terraform está disponibles https://learn.hashicorp.com/terraform/getting-started/install.html[aquí].

En Windows se recomienda instalarlo con https://chocolatey.org/docs/installation[Chocolatey]. Así que si previamente has instalado Chocolatey, simplemente abre una ventana de comandos (cmd) con *permiso de administrador* y ejecuta: 

[source,bash]
----
choco install terraform -y
----

=== GCloud CLI para  GCP

Google Cloud Command Line Interface está disponible para su instalación https://cloud.google.com/sdk/install[aquí].

En Windows se recomienda instalarlo con Chocolatey: abre una ventana de comandos (cmd) con *permiso de administrador* y ejecuta: 

[source,bash]
----
choco install gcloudsdk -y
----

=== Github Student Education Pack

Para poder usar servicios adicionales, como DNS gratuito, debes darte de alta en https://education.github.com/pack[Github Student Education Pack].

Si ya dispones de una cuenta de GitHub, y no quieres crear una cuenta nueva, simplemente debes añadir tu email __@inlumine.ual.es__ a la lista de emails de tu cuenta actual. Para ello, sigue las https://help.github.com/en/github/setting-up-and-managing-your-github-user-account/adding-an-email-address-to-your-github-account[instrucciones]. Tras añadir tu email, haz clic en el enlace https://education.github.com/pack[Get the pack].

== Creación de la infraestructura en Google Cloud

Utilizando una plantilla de terraform crea 2 instancias de máquina virtuales en tu proyecto en Google Cloud: 

. Instancia para instalar Jenkins mediante un contenedor Docker.
. Instancia de despliegue (VM Deploy) con Docker y Docker Composer instalados.

.Máquinas virtuales creadas con Terraform
image::terraform-vm-schema.png[role="thumb", align="center"]

Para crearlas, utiliza la plantilla de terraform disponible en el repositorio https://github.com/ualcnsa/terraformGoogleCloudSample. 
En primer lugar realiza un __fork__ del repositorio, para hacer las modificaciones al mismo que sean necesarias. Después modifica las variables correspondientes para usar tu proyecto en la plantilla, tal y como se describe a continuación.

=== Estructura del proyecto terraform

El repositorio consta de tres archivos con extension .tf, y una carpeta con un template para la creación de instancias.

[source,subs="verbatim,quotes"]
----
terraformGoogleCloudSample
├── instance
│   └── *main.tf* <4>
├── .gitignore
├── README.md
├── *mynetwork.tf* <2>
├── *output.tf* <3>
└── *provider.tf* <1>
----
<1> Descripción del proveedor sobre el que ejecutar la plantilla, en nuestro caso Google Cloud.
<2> Plantilla principal. Crea la red, las reglas de firewall, las 2 instancias llamando al __módulo__ `main.tf` de la carpeta `instance`, y por último realiza la inicialización de cada instancia.
<3> Plantilla con los valores que se muestran de salida al finalizar la ejecución
<4> Módulo genérico para crear una instancia. Es llamado desde `network.tf` pasándole las variables que necesita para crear la instancia.

El archivo `*provider.tf*` deberás modificarlo:

.provider.tf
[source, tf]
----
# Descargar json con credenciales de aquí:
# https://console.cloud.google.com/apis/credentials/serviceaccountkey
# Tras ello definir la variable de entorno apuntando a el json
# export GOOGLE_CLOUD_KEYFILE_JSON=path/file.json

variable "gcp_project" {
  # Configurar el nombre del proyecto en GCP
  default = "cnsa-2021" <1>
}

provider "google" {
  project     = "${var.gcp_project}"
  region      = "us-central1"
}
----
<1> Sustituye este valor por el nombre de tu proyecto (__cnsa2021-abc123__)

Para que terraform pueda conectar al __provider__ Google Cloud desde tu máquina local, debes proporcionar un archivo con credenciales. Descarga el archivo `.json` de aquí: https://console.cloud.google.com/apis/credentials/serviceaccountkey

.Descarga de archivo de credenciales Google Cloud
image::crear-clave-cuenta-servicio.png[role="thumb", align="center"]

<1> Selecciona el proyecto
<2> Selecciona la opción __Compute engine__, y pulsa __Crear__

Guarda el archivo .json en tu proyecto. A continuación, en tu terminal define la variable de entorno apuntando a el archivo recién descargado, sustituyendo `path/file.json` por la ruta relativa y el nombre del archivo de credenciales: 
[source, bash, subs="verbatim,quotes"]
export GOOGLE_CLOUD_KEYFILE_JSON=*path/file.json*


[WARNING]
====
Recuerda: *NUNCA subas tu archivo de credenciales json* a un repositorio público como GitHub. Para evitarlo, añade el nombre el archivo de credenciales al *`.gitignore`*. Se recomienda guardar el archivo `.json` en una carpeta llamada `credentials`, porque ya estaría ignorado, puedes verlo en el *`.gitignore`* del repositorio que has forkeado. 

En el archivo de credenciales va tu clave privada que sustituye a tu usuario y contraseña para crear recursos en GCP. Hay robots que continuamente buscan PRIVATE KEYS y API TOKENS en repositorios públicos como GitHub. Si un __hacker__ accede a ese archivo, lo usará para crear servicios hasta gastar tu crédito por completo, fundamentalmente para minar bitcoins.
====

=== Ejecución de terraform
.Videotutorial
****
Accede al https://drive.google.com/file/d/1_ku2LnVbMmWgns-s8_23ATAQ3nrQEJo2/view?usp=sharing[videotutorial, window="_blank"] explicativo de esta sección (mp4, 20 minutos, 171M).

****
==== `terraform init`
Una vez configurado el __provider__ comprueba que la conexión es correcta: en tu terminal, ejecuta el comando `terraform init` para inicializar el proyecto como un proyecto terraform. Si todo es correcto aparecerá un mensaje de éxito.

.`terraform init` correcto
image::terraform-init-ok.png[role="thumb", align="center"]

Si por el contrario recibes algún mensaje de error, revisa el motivo del error: 

. Terraform puede que no esté accesible. Debería estar en el `PATH`
. Revisa si la variable de entorno si se ha guardado correctamente, ejecuta `echo $GOOGLE_CLOUD_KEYFILE_JSON` y comprueba que es la ruta y nombre de archivo correctos.

==== `terraform plan`

Ejecuta el comando `terraform plan` para ver el resultado de elementos que se crearán o eliminarán al ejecutar la plantilla. Debe aparecer que se crearán 7 elementos. 

.`terraform plan` correcto
image::terraform-plan-ok.png[role="thumb", align="center"]

==== `terraform apply`

Ejecuta el comando `terraform apply --auto-approve` para ejecutar la plantilla. Comenzará a crear los 7 elementos definidos en la plantilla. Tardará unos *5 minutos* o incluso más, así que ten paciencia. Sobre todo tardará en ejecutar los bloques de inicialización de las instancias, en las que se actualizan los paquetes, se instala Docker y otros paquetes. En todo momento verás en pantalla el `log` de las operaciones que se están realizando.

Comprueba que las instancias se han creado correctamente en tu proyecto Google Cloud. 

[WARNING]
====
*Apaga las instancias* cuando dejes de usarlas, para evitar que consuman crédito. 
====

==== `terraform destroy`

Cuando desees eliminar todos los recursos que hemos creado con esta plantilla, simplemente ejecuta `terraform destroy`. Por ahora debes simplemente apagar las instancias cuando no las uses, porque las necesitaremos en el resto de la asignatura.


== Cloud DNS

[TIP]
====
*Este apartado, Cloud DNS, es optativo*. Se evalúa con el 5% de la actividad pero no es obligatorio que lo realices. 
====

Google Cloud ha asignado una IP pública estática a cada una de tus instancias (la IP no cambiará al apagar la instancia y volver a encenderla). A continuación, vamos a asignar nombres de DNS a esas IPs con Cloud DNS y uno de los servicios de DNS disponibles en el Student Pack de GitHub. 

=== Alta de nombre de dominio

GitHub Student pack ofrece varios servicios de nombres dominios gratuitos durante 1 año. Puedes usar __name.com__, __namecheap__, o __.tech domains__. En uno de ellos vamos a dar de alta un nombre de dominio para nuestras instancias en Google Cloud. Voy a describir cómo hacerlo con *.tech*. 

Accede a https://get.tech/github-student-developer-pack[get.tech] y prueba un nombre de dominio que te guste y que esté disponible. 

.Comprobar si el dominio está disponible en get.tech
image::tech-domain-disponible.png[role="thumb", align="center"]

A continuación, inicia sesión con tu cuenta de github, y verás que tienes el descuento por un año. Procede a la compra gratuita. Además, tendrás que registrarte para poder acceder posteriormente a la configuración. Debes completar los datos de registro ya que te identifican como propietario del nombre de dominio. Si lo deseas, usa como dirección __Universidad de Almería, Ctra. Sacramento s/n, 04120, Almería, Spain__. 

=== Configuración de nombres de dominio

Para configurar el nombre de dominio que acabas de adquirir a las IPs reservadas, debes usar Cloud DNS en Google Cloud. Cloud DNS permite asignar los nombres de dominio a las direcciones IP públicas de las instancias. Recuerda comprobar que las IPs son estáticas.

. En el menú de la consola de Google Cloud, entra en *Servicios de red*, *Cloud DNS*.

.Cloud DNS
image::cloud-dns.png[role="thumb", 360, align="center"]

[start=2]
. Haz clic en *Crear Zona*.

.Cloud DNS, crear zona
image::cloud-dns-crear-zona.png[role="thumb", align="center"]

[start=3]
. A continuación, haz clic en *Añadir Conjunto de registros*. Para cada instancia, crea un conjunto de registros.

.Cloud DNS. Crear conjunto de registros, instancia Jenkins
image::cloud-dns-crear-conjunto-de-registros.png[role="thumb", align="center"]

.Cloud DNS. Crear conjunto de registros, instancia de despliegue de apps
image::cloud-dns-crear-conjunto-de-registros2.png[role="thumb", align="center"]

Tras la creación, debes tener un resultado similar a este: 

.Cloud DNS. Detalles de la Zona
image::cloud-dns-detalles-zona.png[role="thumb", align="center"]


[start=4]
. El último paso será modificar los servidores de DNS de la configuración en la web .tech, para poner los valores de los servidores de Google Cloud. Para ello, inicia sesión en get.tech. Entra en tu pedido. 

.get.tech. Acceso al pedido
image::get-tech-manage-orders.png[role="thumb", align="center"]

[start=5]
. Modifica los nombres de los servidores con los valores de tu zona en Cloud DNS

.get.tech. Nombres de los servidores
image::get-tech-manage-servers.png[role="thumb", align="center"]

[start=6]
. Guarda los cambios. Hasta *pasadas 24 horas* no estarán disponibles.


== Instalación de Jenkins

Vamos a usar la primera instancia para instalar Jenkins. En lugar de realizar una https://ualhmis.github.io/Jenkins2Instalacion/[instalación completa sobre el sistema operativo], utilizando los paquetes de Ubuntu, tal como se hace en la asignatura Herramientas y Métodos de Ingeniería del Software, de 3º del Grado en Ingeniería Informática, aquí vas a desplegar Jenkins como un contenedor de  docker. 

=== Construcción de la imagen del contenedor Jenkins

La imagen pública del contenedor de Jenkins está disponible en https://hub.docker.com/r/jenkins/jenkins[DockerHub], con el nombre `jenkins/jenkins:lts`. Esta imagen genérica necesita instalarle algunos plugins y herramientas. En concreto, hay que instalarle el propio Docker para permitir que Jenkins ejecute tareas de docker, como por ejemplo `docker build` para construir imágenes de contenedores. 

Por tanto, vamos a crear una imagen personalizada del contenedor de Jenkins basándonos en la imagen pública e instalándo Docker dentro del contenedor.
Lo más adecuado es que construyas la imagen de Jenkins con Docker en la propia máquina donde lo vamos a ejecutar, es decir en la instancia de jenkins. 

Conecta por ssh a la instancia. Crea una carpeta `jenkins-docker` y crea el archivo `Dockerfile`. Usa el siguiente Dockerfile (descrito en esta entrada de __medium.com__:  https://medium.com/@gustavo.guss/jenkins-building-docker-image-and-sending-to-registry-64b84ea45ee9[Jenkins Building Docker Image and Sending to Registry].

.Dockerfile
[source, docker]
----
FROM jenkins/jenkins:lts

USER root

RUN apt-get update && \
apt-get -y install apt-transport-https \
    ca-certificates \
    curl \
    gnupg2 \
    software-properties-common && \
curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg > /tmp/dkey; apt-key add /tmp/dkey && \
add-apt-repository \
    "deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") \
    $(lsb_release -cs) \
    stable" && \
  apt-get update && \
  apt-get -y install docker-ce

RUN apt-get install -y docker-ce

RUN usermod -a -G docker jenkins

USER jenkins
----

Construimos la imagen a partir del Dockerfile:

[source,bash,subs="verbatim,quotes"]
----
docker build --tag *ualjjcanada*/jenkins-docker:1.0 . <1>
----
<1> Sustituye *ualjjcanada/* por tu usuario de Dockerhub si estás registrado, si no simplemente no lo pongas.

.`docker build` de Jenkins con Docker
image::docker-build-tag.png[role="thumb", align="center"]

.`docker build` successful
image::docker-build-tag-successfully.png[role="thumb", align="center"]

Comprueba que la imagen ha sido creada, y está disponible en tu máquina: `docker image ls`

.`docker image ls`
image::docker-image-ls.png[role="thumb", align="center"]


=== Publicación en Google Container Registry

Opcionalmente podemos publicar nuestra imagen personalizada en DockerHub, o alternativamente el Google Container Registry. Más adelante se describirá cómo hacerlo.

=== Ejecución del contenedor de Jenkins

Ejecutamos el contenedor a partir de la imagen creada previamente. 

. Crear una carpeta para `jenkins_home` que configuraremos como volumen para que los datos de Jenkins se guarden fuera del contenedor. 

[source,bash,subs="verbatim,quotes"]
----
mkdir ~/jenkins_home
chmod 777 ~/jenkins_home
----

[start=2]
. Ejecutamos el contenedor con `docker run`:

[source,bash,subs="verbatim,quotes"]
----
docker run -d --name jenkins-docker -p 80:8080 -p 50000:50000 -v /var/run/docker.sock:/var/run/docker.sock -v ~/jenkins_home:/var/jenkins_home --restart always ualjjcanada/jenkins-docker:1.0
----
 
Los parámetros de `docker run` son:

* `--name jenkins-docker`: nombre que le asignamos al contenedor

* `-p 80:8080`: jenkins se ejecutará en el puerto 80 en el host, que está mapeado al puerto 8080 del contenedor

* `-v /var/run/docker.sock:/var/run/docker.sock`: volumen para compartir el docker socket (usado en la máquina host) con el contenedor. 

* `-v ~/jenkins_home:/var/jenkins_home`: mapea la carpeta local `~/jenkins_home` con la carpeta `/var/jenkins_home` del contenedor. En el contenedor, la carpeta HOME del usuario _jenkins_ es `/var/jenkins_home`, donde Jenkins guarda todos los archivos que utiliza. Si se tira el contenedor o se actualiza, no se pierden los datos ya que se guardan "fuera" del contenedor. 

* `--restart always`: inicia el contenedor cuando se enciende la instancia.

* `ualjjcanada/jenkins-docker:1.0`: imagen del contenedor a ejecutar, la que hemos construido en el paso anterior.

[start=3]
. Comprueba que el contenedor está ejecutándose con `docker ps`

.`docker ps`
image::docker-ps-jenkins.png[role="thumb", align="center"]


=== Configuración básica de Jenkins 

A continuación se muestran los pasos a realizar en el inicio y configuración básica de Jenkins. Además, se describe la instalación de algunos plugins adicionales.

. Conectamos a la IP/URL de la instancia con el navegador web. Aparecerá la ventana para introducir el password inicial. Para ver el password ejecuta: `cat /home/ubuntu/jenkins_home/secrets/initialAdminPassword`

.Contraseña inicial de Jenkins
image::jenkins-unlock.png[role="thumb", align="center"]

[start=2]
. Selecciona Install suggested plugins.

.Install suggested plugins
image::jenkins-install-suggested-plugins.png[role="thumb", align="center"]

Tras unos minutos, introduce los datos del  usuario administrador de Jenkins. Introduce un nombre de usuario y contraseña.

Acepta el nombre de dominio de la máquina. Si aun no has registrado el nombre de dominio, lo puedes hacer más tarde en la configuración general de Jenkins. 

Jenkins está listo.

.Bienvenida a Jenkins
image::jenkins-welcome.png[role="thumb", align="center"]

=== Instalación de plugins adicionales

Vamos a instalar varios plugins: greenballs, NodeJs, GitHub integration, Docker Pipeline. 

Haz clic en __Manage Jenkins__ > __Manage Plugins__. En la pestaña __Available__ busca __Github integration__, seleccionaló y pulsa en __Download now and install after restart__.

.Instalación del plugin Github integration
image::jenkins-plugins-github-integration.png[role="thumb", align="center"]

Repite los pasos para los plugins __Green Balls__, __NodeJS__ y __Docker Pipeline__.

.Instalación del plugin NodeJS
image::jenkins-plugins-nodejs.png[role="thumb", align="center"]

Marca __Restart Jenkins__ para completar la instalación. Tras unos segundos, vuelve a iniciar sesión y tendrás los plugins instalados. 

.Reiniciar para completar la instalación
image::jenkins-plugins-restart.png[role="thumb", align="center"]

=== Configuración las tools en Jenkins

Tras la instalación del plugin https://plugins.jenkins.io/nodejs/[__NodeJS__], es necesario realizar la siguiente configuración: 

. Ve a __Manage Jenkins__, __Global Tool configuration__.
. En *NodeJS*, añade un instalador. Dale por nombre "nodejs" y marca instalar automáticamente. 
. Guarda los cambios.

.Configuración de herramienta NodeJS
image::jenkins-tool-nodejs.png[role="thumb", align="center"]

De la misma forma, instala la última versión de Maven.

.Configuración de herramienta Maven
image::jenkins-tool-maven.png[role="thumb", align="center"]


=== Creación del primer proyecto Jenkins

Creamos el primer proyecto de Jenkins. Comprueba que Jenkins puede llamar a docker. Para ello crea un nuevo proyecto tipo freestyle.

.Nuevo proyecto, freestyle
image::jenkins-new-hello-docker.png[role="thumb", align="center"]

En la sección *Build*, añade un bloque *Execute shell*. Pega estos comandos: 

[source,bash,subs="verbatim,quotes"]
----
whoami
git --version
java -version
docker -v
----

Guarda los cambios. Haz clic sobre *Build now*. Haz clic sobre la bolita azul para ver el la salida por consola.

.Build now. Resultado del build
image::jenkins-new-hello-docker-console-output.png[role="thumb", align="center"]

.Salida por consola
image::jenkins-new-hello-docker-console-success.png[role="thumb", align="center"]

Por consola se visualiza el resultado de ejecutar los comandos dentro del contenedor. Como puedes ver, `git` y `java` están instalados, venían ya en la imagen de jenkins:lts de la que hemos partido en la definición del Dockerfile. Además, `docker` también está disponible, se ha instalado correctamente mediante la definición incluida en el Dockerfile.

=== Creación del primer pipeline en Jenkins

Creamos el primer proyecto de Jenkins tipo pipeline. 
Podemos ejecutarlo sobre el nodo master.

[source,bash,subs="verbatim,quotes"]
----
pipeline {
    agent any
    tools {
        maven 'Default Maven'
    }

    stages {
        stage('Build') {
            steps {
                sh '''
                    java -version
                    mvn -v
                  '''
            }
        }
    }
}
----

Y la otra alternativa es que el pipeline se ejecute en un contenedor docker que descargará de DockerHub.


[source,bash,subs="verbatim,quotes"]
----
pipeline {
    agent {
        docker {
            image 'maven:3.6-openjdk-8' <1>
            args '-v $HOME/.m2:/root/.m2'
        }
    }
    stages {
        stage('Build') {
            steps {
                sh '''
                    java -version
                    mvn -v
                  '''
            }
        }
    }
}
---- 
<1> Entre las https://hub.docker.com/_/maven[imágenes de Maven] disponibles están `3.6-openjdk-11`, `3.6-openjdk-15`, etc

=== Conexión con la máquina de despliegue

Para realizar el despliegue, deberás permitir que Jenkins ejecute unos comandos en la máquina de despliegue. Para ello, la instancia Jenkins debe poder conectarse a la instancia de despliegue mediante una conexión SSH basada en autenticación por pareja de claves pública/privada, que ha demostrado ser más seguro sobre la autenticación estándar de nombre de usuario/contraseña.

.Esquema de despliegue con Jenkins
image::deploy-schema-full.png[role="thumb", align="center"]

Para ello, los pasos que se detallan a continuación permiten: 

- generar una nueva pareja de claves que usaremos para el despliegue,
- copiar la clave pública generada en la instancia de despliegue,
- y por último probar que la conexión se realiza correctamente. 

Ejecuta los siguientes pasos: 

==== Generar la nueva pareja de claves de despliegue

. Conecta por SSH a la máquina Jenkins: `ssh ubuntu@__instancia-jenkins__`

.Conexión SSH a la instancia Jenkins
image::ssh-from-developer-to-jenkins.png[role="thumb", align="center"]

[start=2]
. Crea la carpeta donde se va a guardar la nueva pareja de claves: `mkdir /home/ubuntu/jenkins_home/.ssh`
. Crea una pareja de claves ssh de despliegue: `ssh-keygen -t rsa -b 4096`
. Cuando pida el *nombre*, escribe el nuevo nombre *id_rsa_deploy* junto con la ubicación donde Jenkins va a buscar las claves de forma predeterminada, que es: `/home/ubuntu/jenkins_home/.ssh/*id_rsa_deploy*`
. Por último, deja la contraseña en blanco (pulsa ENTER): `Enter passphrase (empty for no passphrase):`

Esto crea la clave privada en `/home/ubuntu/jenkins_home/.ssh/*id_dsa_deploy*` y una clave pública asociada en `/home/ubuntu/jenkins_home/.ssh/*id_dsa_deploy.pub*`. Esta nueva pareja de claves la usaremos exclusivamente para el despliegue de nuestros proyectos. Al haberlos guardado en la carpeta `/home/ubuntu/jenkins_home/` los archivos están accesibles dentro del contenedor, porque recuerda que esa carpeta la habíamos mapeado con la carpeta `/var/jenkins_home` del contenedor.

.Pareja de claves __id_rsa_deploy__
image::jenkins-ls-deploy-keys.png[role="thumb", align="center"]

==== Copiar la clave pública a la instancia de despliegue

[start=6]
. Muestra el contenido de la clave pública: `cat /home/ubuntu/jenkins_home/.ssh/id_rsa_deploy.pub`
. Copia el contenido: con el ratón, selecciona el contenido de la clave, desde “ssh-rsa” hasta el final, y pulsa ENTER (o CTRC+C)

.Copia el contenido de __id_rsa_deploy.pub__
image::jenkins-cat-public-key.png[role="thumb", align="center"]

[start=8]
. Ahora pégalo en tu PC, lo necesitaremos más adelante.
. Desconecta de la máquina Jenkins: `exit`
. Conecta por ssh a la instancia de despliegue

.Conexión SSH a la instancia Jenkins
image::ssh-from-developer-to-deploy.png[role="thumb", align="center"]

[start=11]
. Edita el archivo `authorized_keys`:  `nano home/ubuntu/.ssh/authorized_keys`
. Ese archivo ya tenía una clave pública, la correspondiente a tu pareja de claves personal que inyectamos en la creación de la instancia con Terraform (por eso has podido conectar por ssh a esa máquina). Pega el contenido de la clave pública de despliegue. Ahora debe tener 2 claves públicas.
. Ya puedes desconectar de la instancia de despliegue.


==== Prueba de la conexión desde jenkins a despliegue

Vamos a probar que funciona:

.Conexión SSH desde la instancia Jenkins a la de despliegue
image::jenkins-ssh-to-deploy.png[role="thumb", align="center"]

[start=14]
. Conecta de nuevo a la instancia jenkins y prueba la conexión ssh a la instancia de despliegue. Recuerda que puesto que Jenkins se está ejecutando como un contenedor, debes probar la conexión ssh desde dentro del contenedor: 

[source,bash,subs="verbatim,quotes"]
----
docker exec -it jenkins-docker ssh ubuntu@__instancia_deploy__ -i /var/jenkins_home/.ssh/id_rsa_deploy
----

En el comando anterior: 

- `docker exec -it` indica ejecutar un comando desde dentro del contenedor
- `jenkins-docker` es el nombre del contenedor
- `ssh ubuntu@__instancia_deploy__ -i /var/jenkins_home/.ssh/id_rsa_deploy` es el comando a ejecutar en el contenedor. En este caso, `ssh` con el parámetro `-i ...` para indica la clave privada que debe usar para conectar. 
- Recuerda que `/var/jenkins_home` es la carpeta HOME del usuario _jenkins_ dentro del contenedor, y _jenkins_ es el usuario del contenedor que ejecuta Jenkins.

[start=15]
. La primera vez que realizas una conexión ssh desde un usuario en una máquina origen a una destino, te pregunta si deseas almacenar la clave de host de destino en la lista de hosts conocidos (`known_hosts`) de tu máquina origen. Contesta: `yes`

.Validar la clave del host: *yes*
image::ssh-host-autentication.png[role="thumb", align="center"]

[start=16]
. Si todo ha ido bien, la conexión se ha debido realizar. Sal con `exit`. Si no ha sido así, verifica que la ruta al archivo de la clave privada es correcta, y que el nombre de la máquina de despliegue es correcto. 

. Comprueba que la clave de host de la máquina de destino (despliegue) se ha guardado en la máquina origen (jenkins) en el archivo `~/.ssh/known_hosts` del usuario que ha ejecutado el comando ssh, en nuestro caso, del usuario jenkins de contenedor: `docker exec -it jenkins-docker cat /var/jenkins_home/.ssh/known_hosts`

.Contenido del archivo *known_hosts* en el contenedor
image::ssh-known_hosts.png[role="thumb", align="center"]

[start=18]
. Puedes comprobar también el contenido de __known_hosts__ en el archivo `/home/ubuntu/jenkins_home/.ssh/known_hosts`, ya que recuerda que hay un volumen mapeado entre la carpeta local `/home/ubuntu/jenkins_home` y la carpeta del contenedor `/var/jenkins_home`.

.Contenido del archivo *known_hosts* en la carpeta local
image::ssh-known_hosts-local.png[role="thumb", align="center"]

[start=19]
. Entra en Jenkins y añade el siguiente comando al proyecto __hello_docker__ existente, sustituyendo __MAQUINA_DEPLOY__ por el nombre DNS de la máquina de despliegue.

[source,bash,subs="verbatim,quotes"]
----
ssh -i ~/.ssh/id_rsa_deploy ubuntu@MAQUINA_DEPLOY "pwd && ls -la"
----
Como aclaración de este comando: 

-	el parámetro `-i` indica la clave privada que queremos usar en la conexión ssh
- `"pwd && ls -la"` son comandos básicos que ejecuta sobre la máquina remota. Hemos indicado estos comandos simplemente para probar que la conexión se realiza correctamente. 

.Modificación del proyecto para que ejecute un comando sobre la instancia de despliegue
image::jenksin-hello-docker-ssh-to-deploy.png[role="thumb", align="center"]

Tras ejecutar el proyecto en Jenkins, el resultado debe ser correcto.

.Salida por consola. El comando se ha ejecutado correctamente.
image::jenksin-hello-docker-ssh-to-deploy-output.png[role="thumb", align="center"]


== Ejemplo 1: Aplicación web Java. 

Una vez que hemos configurado correctamente nuestro entorno de CI/CD con Jenkins, vamos a estudiar varios ejemplos tanto en Java como en NodeJs.

En este primer ejemplo en Java, nos vamos a basar en el proyecto PetClinic con Spring Boot, disponible en https://github.com/spring-projects/spring-petclinic[GitHub]. Petclinic es una aplicación https://spring.io/guides/gs/spring-boot[Spring Boot] construida usando https://spring.io/guides/gs/maven/[Maven]. 

https://es.wikipedia.org/wiki/Spring_Framework[Spring Boot] es un framework de código abierto para el desarrollo de aplicaciones Java basadas en https://spring.io/[Spring]. Spring Boot genera una proyecto Maven/Gradle con todo lo necesario y que se autoconfigura en el arranque. Por ejemplo, si decimos que queremos una aplicación web, Spring Boot automáticamente  embebe un Tomcat y lo configura con el servlet de Spring. Toda la configuración la añade al archivo de la herramienta de build __build__ que indiquemos, en caso de Maven, al archivo `pom.xml`.

Recordemos que *Maven* es una herramienta software para la gestión y construcción de proyectos Java. https://maven.apache.org/[Apache Maven] estandariza la configuración de un proyecto en todo su ciclo de vida, como son todas las fases de compilación, ejecución de pruebas, empaquetado, etc. Maven permite la gestión de dependencias entre módulos y distintas versiones de librerías, simplemente indicando los módulos que componen el proyecto, y las dependencias utiliza el software que estamos desarrollando, en un fichero XML de configuración  llamado POM (Project Object Model).


Para el proyecto PetClinic, en tu máquina de desarrollo local puedes construir el .jar (empaquetado) y ejecutar Petclinic:

[source,bash]
----
git clone https://github.com/spring-projects/spring-petclinic.git
cd spring-petclinic
./mvnw package <1>
java -jar target/*.jar <2>
----
<1> Llama al _warper_ de Maven que instala Maven (si es necesario), y ejecuta el __goal__ `*package*` que se encarga de compilar, ejecutar los test y empaquetar la aplicación en un único archivo ejecutable `.jar`. La primera vez que lances la construcción tardará más de 5 minutos, ya que tiene que descargar todas las dependencias necesarias desde los repositorios de Maven (Maven Central), y después lanzar los tests. Toda la configuración necesaria está contenida en el archivo `pom.xml` de Maven.

<2> Ejecuta la aplicación a partir del `.jar`. Puedes acceder a PetClinic en: http://localhost:8080/

.Página principal de PetClinic
image::petclinic-homepage.png[role="thumb", align="center"]

En su configuración predeterminada, Petclinic utiliza una base de datos en memoria (H2) que se inicia con datos predeterminados, y los nuevos datos que se guarden se pierden al reiniciar la aplicación. 

En caso de necesitar persistencia de los datos, PetClinic también está preconfigurada para usar MySql. Para cambiar el tipo de base de datos, la aplicación debe ejecutarse con un perfil de MySql: `spring.profiles.active=mysql`.

[source,bash]
----
java -Dspring.profiles.active=mysql -jar target/*.jar 
----

Recuerda que para ejecutarla en este modo, debes tener un MySql funcionando en local, o bien lanzar MySql como contenedor con *docker* o con *docker-compose*. Existe un archivo `docker-compose.yml` disponible en el proyecto, por tanto puedes iniciar MySql así:

[source,bash]
----
docker-compose up -d 
----

El archivo `docker-compose.yml` que permite iniciar MySql puedes consultarlo en la carpeta raíz del proyecto, y es el siguiente:

[source,yml,subs="verbatim,quotes"]
----
mysql:
  image: mysql:5.7
  ports:
    - "3306:3306"
  environment:
    - MYSQL_ROOT_PASSWORD=
    - MYSQL_ALLOW_EMPTY_PASSWORD=true
    - MYSQL_USER=petclinic
    - MYSQL_PASSWORD=petclinic
    - MYSQL_DATABASE=petclinic
  volumes:
    - "./conf.d:/etc/mysql/conf.d:ro"
----

=== Creación de proyecto Jenkins con pipelines

Una vez que hemos probado la ejecución y funcionamiento de la aplicación PetClinic en local, vamos a configurar el proyecto en el servidor Jenkins de CI/CD para que este se encargue de  la construcción y el despliegue automatizados.

Conecta a tu Jenkins, y crea un nuevo item de tipo Pipeline. Dale el nombre 'spring-petclinic-pipeline':

.New Item, PetClinic pipeline
image::new-item-pipeline-petclinic.png[role="thumb", align="center"]

En el bloque Pipeline, pega la configuración siguiente:

[source,groovy]
----
pipeline {
  agent any <1>

  tools {
    // Previamente has debido instalar Maven con el nombre "Default Maven"
    maven "Default Maven" <2>
  }

  stages { <3>
    stage('Git fetch') { <4>
      steps {
        // Get some code from a GitHub repository
        git 'https://github.com/spring-projects/spring-petclinic.git'
      }
    }
    stage('Compile, Test, Package') { <5>
      steps {
        // Run goal 'package' includes compile, test and package.
        sh "mvn clean package"
      }
      post { <6>
        // If Maven was able to run the tests, even if some of the test
        // failed, record the test results and archive the jar file.
        success {
          junit '**/target/surefire-reports/TEST-*.xml'
          archiveArtifacts 'target/*.jar'
        }
      }
    }
  }
}
----
<1> agente o nodo de Jenkins en que ejecuta la construcción del  proyecto. En el ejemplo, `any` indica que se ejecutará cualquier nodo, en nuestro caso será en __master__ ya que es el único nodo que hay definido en nuestro Jenkins.
<2> como herramienta para la construcción se usará maven. Pon aquí el nombre que diste a tu instalación de Maven configurada previamente en Tools Configuration. 
<3> Bloque de `stages`: fases o etapas que conforman el pipeline
<4> Fase de descarga del repositorio git
<5> Fase de compilación, ejecución de test y empaquetado de la aplicación. Se realizarán con los __goals__ `clean package`: primero se elimina todo lo generado en la construcción anterior, y a continuación se lanza la construcción con `package` tal y como está definida en el archivo `pom.xml`.
<6> Paso posterior que guarda los resultados de los test de JUnit para generar la gráfica de evolución de los test.

Tras ejecutar el pipeline, con "Build now", el resultado debe ser el siguiente:

.Construcción del pipeline PetClinic
image::petclinic-pipeline-build-1.png[role="thumb", align="center"]

Si realizamos una segunda ejecución, ya aparecerá la gráfica de evolución de los tests de JUnit. 

=== Informe de Cobertura de código

Jenkins nos permite publicar métricas asociadas al proyecto. Una de ellas, es la cobertura de código ejecutado por las pruebas. 

****
La *Cobertura* de código nos indica el porcentaje de código de producción que está siendo ejecutado por los test. Es deseable tener un valor de cobertura lo más próximo posible al 100%
****

El proyecto PetClinic contiene 40 test unitarios en JUnit, y está configurado (ver `pom.xml`) para que se calcule la cobertura cuando se lanzan los tests mediante el plugin JaCoCo (Java Code Coverage). Puedes visualizar el resultado de la cobertura en tu construcción local, en la carpeta `target/site/jacoco`: 

.Archivos generados por Jacoco
image::jacoco-local-results.png[role="thumb", align="center"]

.Informe html de la cobertura Jacoco
image::jacoco-local-html.png[role="thumb", align="center"]

Y si haces clic en el nombre de una clase, verás el código coloreado: 

.Detalle la cobertura de las lineas de código
image::plugins-jacoco-class-details.png[role="thumb", align="center"]
<1> Las lineas [lime-background]#verdes# están cubiertas, es decir, han sido ejecutadas por al menos 1 test.
<2> Las lineas [yellow-background]#amarillas# están parcialmente cubiertas (__missed branches__): un resultado de la condición (verdadero/falso) ha sido ejecutado por algún test pero el otro no ha sido ejecutado por ningún test.
<3> Las líneas [red-background]#rojas# no están cubiertas, no han sido ejecutadas por ningún test.


Para visualizar el resultado de la cobertura en Jenkins: 

. Instala el plugin de Jacoco y el plugin Code Coverage API

.Instalación del plugin Jacoco
image::plugins-jacoco-install.png[role="thumb", align="center"]

.Instalación del plugin Code Coverage API
image::plugins-code-coverage-api-install.png[role="thumb", align="center"]

[start=2]

. Añade las dos siguientes lineas al bloque `post` para que se guarde y muestre el informe de cobertura.

[source,groovy]
----
  ...
  success {
    junit '**/target/surefire-reports/TEST-*.xml'
    archiveArtifacts 'target/*.jar'
    jacoco(execPattern: 'target/jacoco.exec') <1>
    publishCoverage adapters: [jacocoAdapter('target/site/jacoco/jacoco.xml')] <2>
  }
  ...
----

<1> Añade el informe Coverage Trend
<2> Añade el informe Coverage Report

Tras la construcción de nuevo del proyecto, verás la gráfica de los resultados de los test y debajo la gráfica de evolución de cobertura: 

.Informe de cobertura en el dashboard
image::plugins-jacoco-dashboard-result.png[role="thumb", align="center"]

Haciendo clic sobre la gráfica accedes a los detalles: 

.Detalle de de cobertura
image::plugins-jacoco-details-result.png[role="thumb", align="center"]


=== Análisis estático de código: __Checkstyle__

Para mantener y aumentar la calidad de nuestro código debemos ayudarnos, entre otras herramientas, de técnicas de https://es.wikipedia.org/wiki/An%C3%A1lisis_est%C3%A1tico_de_software[*análisis estático de código*]. Básicamente, se encargan de buscar defectos en el código sin necesidad de que este se ejecute. En Java una de las más habituales es https://checkstyle.sourceforge.io/[Checkstyle], aunque hay otras como FindBugs, PMD, y SonarQube que integra a los anteriores. 

****
*CheckStyle* valida el estilo del código respecto al estilo oficial de Java.
****

El proyecto PetClinic tiene configurado el plugin de CheckStyle en el `pom.xml`: 

[source,xml]
----
    ...
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-checkstyle-plugin</artifactId>
        <version>3.1.0</version>
        ...
      </plugin>
    ...
----

Para ejectutar CheckStyle en local, ejecuta el comando de maven (`mvn`) con los siguietnes __goals__: `mvn checkstyle:checkstyle site -DgenerateReports=false`

Tras la ejecución, en la carpeta `target/site/` verás el archivo `checkstyle.html`:

.Informe de CheckStyle
image::checkstyle-report-html.png[role="thumb", align="center"]

Sería labor del equipo de desarrollo revisar los errores detectados y tratar de corregirlos, siempre que realmente supongan una mejora para la calidad del código. 

Para ejecutar y visualizar el informe en Jenkins: 

. Instalar el plugin https://github.com/jenkinsci/warnings-ng-plugin/blob/master/doc/Documentation.md#declarative-pipeline-configuration[Warnings Next Generation].
. Añadir al pipeline un nuevo `stage` con la siguiente descripción: 


[source,groovy]
----
  stage ('Analysis') {
    steps {
      // Warnings next generation plugin required
      sh "mvn checkstyle:checkstyle site -DgenerateReports=false"
      recordIssues enabledForFailure: true, tool: checkStyle() 
    }
  }
----

Tras la construcción, el pipeline tiene una nueva fase y además en el menú tenemos acceso al informe de CheckStyle.

.Pipeline con la nueva fase de Análisis
image::checkstyle-report-dashboard.png[role="thumb", align="center"]

.Detalles del informe de CheckStyle
image::checkstyle-report-details.png[role="thumb", align="center"]

.Saber más...
****
Si estás interesado en profundizar en este tema, te recomiendo integrar https://www.sonarqube.org/[SonarQube] con Jenkins, ya que SonarQube realiza un análisis mucho más detallado de la calidad y seguridad del código, realizando tanto análisis estático de código (CheckStyle y otros), como de análisis de seguridad (vulnerabilidades), y definiendo lo que denomina https://docs.sonarqube.org/latest/user-guide/quality-gates/[__Quality Gates__] que permiten definir condiciones que se deben cumplir basadas en los valores de las métricas del proyecto (por ejemplo, que la cobertura de código sea mayor del 80%). Puedes encontrar mucha documentación online sobre cómo hacerlo:

- https://docs.sonarqube.org/latest/setup/get-started-2-minutes/[Instalar SonarQube] como aplicación o como contenedor Docker (recomendado)
- Instalar el plugin https://plugins.jenkins.io/sonar/[SonarQube Scanner for Jenkins]
- https://docs.sonarqube.org/latest/analysis/scan/sonarscanner-for-jenkins/#header-1[Configurar] SonarQube Scanner for Jenkins
- https://docs.sonarqube.org/latest/analysis/scan/sonarscanner-for-jenkins/#header-6[Añadir al pipeline] la fase de análisis de Sonar (_Declarative pipeline example:_). Más info de Sonar en pipeline: https://www.jenkins.io/doc/pipeline/steps/sonar/#sonarqube-scanner-for-jenkins[SonarQube Scanner for Jenkins]


Además, Si tu proyecto está en un repositorio público en GitHub, puedes ahorrarte tener que instalar tu propio SonarQube utilizando https://sonarcloud.io/[SonarCloud], el servicio de SonarQube en la nube (SaaS) gratuito para proyectos públicos, con el que evitas tener que instalar y mantener tu propio SonarQube. 

Para lanzar el análisis de Sonar con maven:

. Genera el login https://docs.sonarqube.org/latest/user-guide/user-token/[TOKEN]

. Ejecuta los goals de maven: `clean verify sonar:sonar -Dsonar.login=$SONAR_LOGIN_TOKEN`

Incluso puedes configurar SonarCloud y Jenkins para que  https://blog.jdriven.com/2019/08/sonarcloud-github-pull-request-analysis-from-jenkins/[analizar los __pull request__] de tu repositorio y conocer el resultado del análisis de Sonar antes de hacer el __merge__ del pull request.
****

=== Despliegue en la VM

Para desplegar la aplicación PetClinic en la instancia de despliegue vamos a copiar sobre ella el archivo JAR y a continuación ejecutaremos en ella la orden de java para ponerla en marcha: 

Copia este nueva fase en tu pipeline, sustituyendo DEPLOY_MACHINE por el nombre DNS de tu instancia: 

[source,groovy]
----
  stage('Deploy'){
    steps {
      sh '''
        ssh -i ~/.ssh/id_rsa_deploy ubuntu@DEPLOY_MACHINE "mkdir -p ~/spring-petclinic" <1>
        scp -i ~/.ssh/id_rsa_deploy $WORKSPACE/target/*.jar ubuntu@DEPLOY_MACHINE:~/spring-petclinic <2>
        ssh -i ~/.ssh/id_rsa_deploy ubuntu@DEPLOY_MACHINE "if pgrep java; then pkill java; fi" <3>
        ssh -i ~/.ssh/id_rsa_deploy ubuntu@DEPLOY_MACHINE "nohup java -jar ~/spring-petclinic/*.jar > ~/spring-petclinic/yourservice.log 2>&1 &" <4>
      '''
    }
  }
----
<1> Crea la carpeta `spring-petclinic` dentro de la carpeta HOME del usuario `ubuntu` en la máquina de despliegue
<2> Copia con `scp` el archivo `.jar`, que se ha generado tras la construcción con maven, en la máquina de despligue
<3> Detiene el proceso `java` si existe de un despliegue anterior.
<4> Ejecuta la aplicación java empaquetada en el `.jar`, en background y con `nohup`, que hace que el proceso siga funcionando incluso si el usuario que lo inició cierra la sesión. De esta manera finaliza el comando ssh y el proceso sigue funcionando, es decir, la aplicación PetClinic estará desplegada y funcionando. 

****
Referencias:

. https://medium.com/@weblab_tech/how-to-publish-artifacts-in-jenkins-f021b17fde71[How to build on Jenkins and publish artifacts via ssh with Pipelines]
****

== Aplicación web Java con Docker

Para realizar el despliegue de PetClinic como contenedor, primero tenemos que https://www.callicoder.com/spring-boot-docker-example/[dockerizar] la aplicación, luego publicar la imagen de contenedor en un registro como DockerHub o Google Container Registry, y por último ejecutar el contenedor en la instancia de despliegue.

A continuación se describe cómo crear un contenedor Docker de la aplicación PetClinic. Los pasos se realizan en local, y al final configuraremos el pipeline de Jenkins para que se realicen automáticamente. 

=== Creación del `Dockerfile`

Para https://spring.io/guides/gs/spring-boot-docker/[crear el contendedor de Docker] que empaquete la aplicación PetClinic, vamos a definir el siguiente archivo `Dockerfile` que debe estar en la carpeta raíz del proyecto:

.Dockerfile
[source, docker]
----
# Start with a base image containing Java runtime
FROM openjdk:8-jdk-alpine
# Make port 8080 available to the world outside this container
EXPOSE 8080
# The application's jar file
ARG JAR_FILE=target/*.jar
# Copy the application's jar to the container
COPY ${JAR_FILE} app.jar
# Run the jar file
ENTRYPOINT ["java","-jar","/app.jar"]
----

El Dockerfile es muy sencillo, contiene los pasos básicos para ejecutar una aplicación String Boot en un contenedor: partiendo de una imagen de `openjdk`, copia el archivo `target/*.jar` en el contenedor con el nombre `app.jar` y lo ejecuta mediante el comando `ENTRYPOINT` para que no haya ninguna shell sobre el proceso `java`. 

Puedes construir la imagen del contenedor:

. Construye el proyecto PetClinic con maven en tu equipo local:

[source, bash]
----
./mvnw clean package
----

.Resultado de la construcción local con Maven
image::mvn-package-petclinic.png[role="thumb", align="center"]

[start=2]
. Construye el contenedor con `docker build`:

[source, bash]
----
docker build -t petclinic-docker .
----

.Docker build
image::docker-build-petclinic.png[role="thumb", align="center"]

[TIP]
====
Para trabajar con contenedores Docker en tu equipo local, debes tener Docker instalado. Recuerda iniciar Docker Desktop en Windows, o iniciar el servicio Docker en Linux o Mac. Comprueba que está funcionado ejecutando el comando `docker ps`
====

Prueba la ejecución del contenedor en local: 

[source, bash]
----
docker run -it -p 8080:8080 -t petclinic-docker
---- 

Comprueba que se ha iniciado la aplicación en http://localhost:8080.

Para el contenedor con CTRL+C.

Una vez creada la imagen con `docker build` y probada su ejecución con `docker run`, el siguiente paso será publicar la imagen en un registro de contenedores, mediante `docker push`. Podemos usar https://hub.docker.com/[DockerHub] pero en este caso vamos a usar Google Cloud https://cloud.google.com/container-registry?hl=es[Container Registry]. 

=== Autenticación en Container Registry

Para poder hacer `push` debemos tener permisos de escritura, y por tanto debemos autenticarnos en el servicio Container Registry. 

https://cloud.google.com/container-registry/docs/advanced-authentication[Authentication] _allows you to connect to Container Registry with your credentials. To push or pull images, you must configure the permissions that are required to access the registry._

_Using https://cloud.google.com/container-registry/docs/advanced-authentication#json-key[JSON key file] as authentication method:_

_To create a new service account and a service account key for use with Container Registry repositories only:_

. _Create the service account for interacting with repositories:_

.. In Google Cloud Console, open the https://console.cloud.google.com/apis/credentials/serviceaccountkey?_ga=2.71233296.1082389881.1588672109-358507209.1586347394[Create service account key page]._

.. _From the Service account list, select New service account_

.. _In the Service account name field, enter a name_
.. _From the Role list, select the appropriate Container Registry role for the service account: Cloud Storage / Storage Administrator_
.. _Click Create. A JSON file that contains your key downloads to your computer._

.Creación Service Account Key for pull/push on Container Registry
image::cloud-containers-registry-key-create.png[role="thumb", align="center"]

[start=2]
. Guarda el archivo `.json` en la carpeta `secret` de tu proyecto PetClinic. 

[WARNING]
====
No olvides añadir la carpeta `secret/` al archivo `.gitignore` para evitar publicar en GitHub tu archivo de credenciales.
====

[start=3]
. _Use the service account key as your password to authenticate with Docker._ Sustituye `keyfile.json` por el nombre de tu archivo de credenciales:

.. En Linux: 

[source, bash]
----
cat keyfile.json | docker login -u _json_key --password-stdin https://gcr.io
----

[start=2,]
  .. En Windows:

[source, bash]
----
docker login -u _json_key --password-stdin https://gcr.io < keyfile.json
----


.Autenticación de Docker contra Container Registry
image::cloud-containers-registry-login.png[role="thumb", align="center"]



=== Publicación y despliegue _manual_

. Construir el contenedor con el nombre completo incluyendo la referencia a Container registry (gcr.io). Primero definimos una variable de entorno con el nombre de nuestro proyecto GCP, y luego construimos de nuevo la imagen con el nombre completo del registro de contenedores: 


[source, bash]
----
GOOGLE_CLOUD_PROJECT=cnsa-2021-user123

docker build -t gcr.io/$GOOGLE_CLOUD_PROJECT/petclinic:1.0 .
----

 
[start=2]
. A continuación vamos a publicar con `docker push`: habilita la API de Container Registry en tu proyecto GCP

.Habilitar la API Container Registry
image::container-registry-habilitar-api.png[role="thumb", align="center"]

[start=3]
. Publica la imagen con ```docker push [HOSTNAME]/[PROJECT-ID]/[IMAGE]:[TAG]```: 

[source, bash]
----
docker push gcr.io/$GOOGLE_CLOUD_PROJECT/petclinic:1.0
----

[start=4]
. Comprueba que se ha publicado correctamente.

.Lista de imágenes en Container Registry
image::container-registry-pushed-petclinic.png[role="thumb", align="center"]

La imagen del contenedor PetClinic ya está disponible en el registro privado de nuestro proyecto GCP. Utilizando nuestras credenciales podremos hacer `docker pull` de dicha imagen para descargarla en cualquier máquina con docker, y ejecutarlo con `docker run`.

[source, bash]
----
GOOGLE_CLOUD_PROJECT=cnsa-2021-user123

docker run -p 8080:8080 -t --name petclinic  gcr.io/$GOOGLE_CLOUD_PROJECT/petclinic:1.0
---- 

Si conectas a la instancia de despliegue que creamos al principio de esta actividad, y ejecutas el comando `docker run` anterior, dará un error de autenticación:

.Error de autenticación en Container Registry
image::docker-run-petclinic-webapp-error-authentication.png[role="thumb", align="center"]

Para arreglarlo, habrá que copiar en la máquina de despliegue el archivo de credenciales `.json` con premisos sobre Container Registry. A continuación se muestran los comandos necesarios para ello. Una vez disponible este archivo en la instancia de despliegue ejecutar el comando `docker login` y tras ello ya si podremos hacer `docker pull` y `docker run`.

[source, bash]
----
# Compiamos el archivo de credenciales
scp ./secret/file.json ubuntu@DNS_MAQUINA_DEPLOY:~/file.json
# Conectamos a la máquina de despliegue
ssh ubuntu@DNS_MAQUINA_DEPLOY
# Autenticamos docker contra Container Registry
cat keyfile.json | docker login -u _json_key --password-stdin https://gcr.io
# ejecutamos el contenedor desde gcr.io
docker run -d -p 8080:8080 -t --name petclinic gcr.io/$GOOGLE_CLOUD_PROJECT/petclinic:1.0
---- 

Es posible que la ejecución del contenedor de un error, porque el puerto 8080 ya esté en uso:

[source, bash]
----
Error starting userland proxy: listen tcp 0.0.0.0:8080: bind: address already in use. 
----

Para solucionarlo, bien detén el proceso java que está corriendo con la aplicación PetClinic tal y como la desplegamos en la sección anterior (```if pgrep java; then pkill java; fi```), o bien utiliza otro puerto, por ejemplo, el 80, que debe estar disponible: 

[source, bash]
----
docker run -p 80:8080 -t --name petclinic gcr.io/$GOOGLE_CLOUD_PROJECT/petclinic:1.0
----

=== Integración y despliegue continuo con Jenkins

Hasta ahora hemos realizado todos los pasos de construcción, prueba y despliegue manualmente. A continuación, vamos a automatizar en Jenkins todo el proceso, cuyas principales tareas son: 

****
- la *construcción* de la imagen del contenedor, 
- la *publicación* de la imagen en el registro, y
- el *despliegue* del contenedor.
****
En Jenkins, son necesarios los siguientes plugins para trabajar con Docker y pipelines, y con Container Registry: Docker Pipeline, que ya está instalado, y tendrás que instalar https://plugins.jenkins.io/google-container-registry-auth[Google Container Registry Auth].

Definimos un nuevo proyecto en Jenkins de tipo pipeline, con el nombre ```PetClinic-Docker-abc123``` sustituyendo abc123 por nuestro nombre de usuario. Son necesarios 3 fases (stages) en el pipeline: _build image_, _push image_, y _deploy container_.

==== Construcción y despliegue "local"

Comenzamos por la *construcción de la imagen*:

[source,groovy]
----
pipeline {
  agent any 
  environment {
    CONTAINER_REGISTRY = 'gcr.io'
    GOOGLE_CLOUD_PROJECT = 'cnsa-2021-abc123'
    CREDENTIALS_ID = 'cnsa-2021-gcr'
  }
  tools {
    maven "Default Maven" 
  }
  stages {
    stage("Checkout code") {
      steps {
        // checkout scm
        git 'https://github.com/ualcnsa/spring-petclinic.git'
      }
    }
    stage('Compile, Test, Package') { 
      steps {
        sh "mvn clean package"
      }
      post { 
        success {
          junit '**/target/surefire-reports/TEST-*.xml'
          archiveArtifacts 'target/*.jar'
        }
      }
    }
    stage("Build image") {
      steps {
        script {
          dockerImage = docker.build(
            "${env.CONTAINER_REGISTRY}/${env.GOOGLE_CLOUD_PROJECT}/petclinic:${env.BUILD_ID}",
            "-f Dockerfile ."
          ) 
      }
    }
  }
}
----

Para probar que la imagen del contenedor se ha creado bien, añade esta fase que hace un despliegue "local" en la propia máquina de Jenkins, es decir, ejecuta un contenedor basado en la imagen que acabamos de crear: 

[source,groovy]
----
    stage("Run image locally") {
      steps {
        sh "docker stop petclinic || true && docker rm  petclinic || true" <1>
        sh "docker run -d -p 8080:8080 -t --name petclinic ${env.CONTAINER_REGISTRY}/${env.GOOGLE_CLOUD_PROJECT}/petclinic:${env.BUILD_ID}" <2>
      }
    }
----
<1> Por si ya se ha ejecutado el pipeline anteriormente, y no se ha eliminado el contenedor de la ejecución anterior, es necesario comprobar si el contenedor `petclinic` ya se está ejecutando y, en tal caso, pararlo con `docker stop` y eliminarlo con `docker rm`
<2> Con `docker run` ejecuta el contenedor `petclinic` a partir de la imagen recién construida. Para que  el pipeline pueda finalizar y el contenedor siga ejecutándose, se añade `-d` que indica modo _detached_ que ejecuta el contenedor en background.

La aplicación debe estar accesible en el puerto 8080 en tu máquina de Jenkins. Para asegurarnos que la aplicación se está ejecutando bien, debemos problarlo "manualmente". Para automatizar esta prueba, lo adecuado sería realizar unos tests end-to-end, con https://www.selenium.dev[Selenium]. Esto se explicará en otra actividad, dedicada al testing.

[source,groovy]
----
    stage('End-to-end Test image') {
        // Ideally, we would run some end-to-end tests against our running container.
        steps{
            sh 'echo "End-to-end Tests passed"'
        }
    }
----

==== Publicación en el registro

El siguiente paso es *publicar la imagen* en el registro.

. Primero, es necesario crear unas credenciales en Jenkins para poder hacer `push` en Container Registry:

.. _Go to jenkins home, click on “credentials” and “(global)”_

.. _Click on “Add Credentials” in left menu._

.. _Select *Google Service Account from private key* for the “Kind” field, and enter your project name ( myregistry in this example). Then upload the JSON private key._

.Credenciales en Jenkins para Container Registry
image::jenkins-credentials-container-registry.png[role="thumb", align="center"]

[start=2]
. Una vez guardadas las credenciales, vamos a definir la fase para publicar la imagen del contenedor: 

[source,groovy]
----
  stage("Push image") {
    steps {
      script {
        docker.withRegistry('https://'+ CONTAINER_REGISTRY, 'gcr:'+ GOOGLE_CLOUD_PROJECT) {
          dockerImage.push("latest")
          dockerImage.push("${env.BUILD_ID}")
        }        
      }
    }
  }        
----

Comprobar que se ha publicado correctamente en el registro.

.Imagen publicada en Container Registry, etiquetada con el número de build
image::jenkins-published-container-registry.png[role="thumb", align="center"]


==== Despliegue en producción

Por último, quedaría el paso de *desplegar al entorno de producción*. Una vez empaquetada como un contenedor, Google Cloud permite desplegar de varias formas:

****
- en *máquina virtual* con GCE, 
- en plataforma como servicio con *Google App Engine*,
- en Kubernetes con *GKE*,
- y en *Cloud Run*, un servicio de Google Cloud específico para el despliegue de contenedores. 
****

Para nosotros, la *máquina virtual de despliegue* es nuestro entorno de producción en el que vamos a desplegar el contenedor. 

Los pasos para el despliegue de la nueva imagen del contenedor consistirán en ejecutar los siguientes comandos sobre la máquina de despliegue:

- `docker stop` del contenedor por si estuviera ejecutándose  
- `docker rm` para eliminar el contenedor existente, que puede estar basado en una imagen de una versión anterior
- `docker run` para ejecutar el contenedor, que automáticamente  hará un `docker pull` de la imagen actualizada del registro. Lo lanzaremos en el puerto 80 ya que el 8080 está ocupado por el despliegue que hicimos sin contenedor. 

Estas acciones debemos añadirlas a un `stage` del pipeline de Jenkins que se encargará de desplegar el nuevo contenedor automáticamente. En el siguiente código, sustituye `DNS_DEPLOY_INSTANCE` por el nombre DNS de tu instancia de despliegue. También puedes definirla como una variable de entorno al inicio del pipeline.

[source,groovy]
----
    stage('Deploy to Production') {
      steps{
        sh '''
          ssh -i ~/.ssh/id_rsa_deploy ubuntu@DNS_DEPLOY_INSTANCE "if docker ps -q --filter name=petclinic | grep . ; then docker stop petclinic ; fi" <1>
          ssh -i ~/.ssh/id_rsa_deploy ubuntu@DNS_DEPLOY_INSTANCE "if docker ps -a -q --filter name=petclinic | grep . ; then docker rm -fv petclinic ; fi" <2>
          ssh -i ~/.ssh/id_rsa_deploy ubuntu@DNS_DEPLOY_INSTANCE "docker run -d -p 80:8080 -t --name petclinic ${CONTAINER_REGISTRY}/${GOOGLE_CLOUD_PROJECT}/petclinic:latest" <3>
        '''
      }
    }    
----
<1> Ejecuta en la instancia de despliegue el comando `docker stop` que detiene el contenedor `petclinic` en caso de que ya se estuviera ejecutando de un despliegue anterior. Esto se comprueba con `docker ps ...`.
<2> Ejecuta en la instancia de despliegue el comando `docker rm` que elimina el contenedor `petclinic` en caso de que exista de un despliegue anterior. Esto se comprueba con `docker ps -a ...`. Estos dos pasos, parar el contenedor y eliminar el contenedor, son necesarios realizarlos antes de volver a lanzar un nuevo contenedor con el mismo nombre. Se ejecuta en dos pasos para evitar errores en caso de que el contenedor exista pero no esté en ejecución, lo que podría dar lugar a un error en el despliegue.
<3> Ejecuta en la instancia de despliegue el comando para ejecutar el contenedor basado en la última versión de la imagen, lanzándolo con `-d` que indica modo _detached_ que ejecuta el contenedor en background, para que el pipeline finalice y el contenedor permanezca en ejecución.

[TIP]
====
Algunos https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf[comandos] útiles de Docker:
```
# Remove all stopped containers
docker rm $(docker ps -a -q)
# Remove all images
docker rmi $(docker images -q)
```
====
  
La aplicación PetClinic debe estar accesible _en producción_, en el puerto 8080 en la instancia de despliegue. Para asegurarnos, debemos problarlo "manualmente". Para automatizar esta prueba _en producción_, lo adecuado de nuevo sería realizar unos tests end-to-end, con https://www.selenium.dev[Selenium]. Esto se explicará en otra actividad, dedicada al testing.

[source,groovy]
----
    stage('End-to-end Test on Production') {
        // Ideally, we would run some end-to-end tests against our running container.
        steps{
            sh 'echo "End-to-end Tests passed on Production"'
        }
    }
----

Por último, es una buena práctica eliminar las imágenes que se van generando en cada build, para liberar espacio en la máquina de Jenkins. Primero paramos y eliminamos el contenedor que desplegamos anteriormente en la fase del pipeline `Run image locally`; luego eliminamos la imagen.

[source,groovy]
----
    stage('Remove Unused docker image') {
      steps{
        // input message:"Proceed with removing image locally?" <1>
        sh 'if docker ps -q --filter name=petclinic | grep . ; then docker stop petclinic && docker rm -fv petclinic; fi' <2>
        sh 'docker rmi ${CONTAINER_REGISTRY}/${GOOGLE_CLOUD_PROJECT}/petclinic:$BUILD_NUMBER' <3>
      }
    }
----
<1> Pide confirmación al usuario, que tendrán que pulsar un botón de _Proceed_ para continuar la ejecución del pipeline
<2> Para y elimina el contenedor _local_ 
<3> Elimina la imagen de contenedor en _local_ con `docker rmi` para liberar espacio.

.Input message (paso comentado en el ejemplo)
image::jenkins-petclinic-full-pipeline-proceed.png[role="thumb", align="center"]

El pipeline completo, con todas sus fases, debe quedar así:

.Pipeline completo
image::jenkins-petclinic-full-pipeline.png[role="thumb", align="center"]

Enhorabuena!! Has conseguido definir un pipeline completo de integración y despliegue continuos, y con contenedores. Este proceso se puede aplicar, con pequeñas adaptaciones, a cualquier otro proyecto Java basados en Maven. 

Si usas otras tecnologías, como NodeJs, hay que adaptar cada una de las fases a su equivalente en NodeJs. Vamos a verlo en la siguiente sección.


****
Referencias

. Deploy via ssh: https://medium.com/@weblab_tech/how-to-publish-artifacts-in-jenkins-f021b17fde71[How to build on Jenkins and publish artifacts via ssh with Pipelines] @ Medium 


. https://medium.com/@gustavo.guss/jenkins-building-docker-image-and-sending-to-registry-64b84ea45ee9[Jenkins Building Docker Image and Sending to Registry] @ Medium

. https://stackoverflow.com/questions/54573068/pushing-docker-image-through-jenkins[Pushing docker image through jenkins] @ StackOverflow

****

////
// Ejemplo 2: Hola Mundo en NodeJs
////

include::node-example.adoc[]

////
// Aplicación NodeJs con Docker
////
include::node-pipeline.adoc[]
